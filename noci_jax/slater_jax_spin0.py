# Copyright 2023 NOCI_Jax developers. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
'''
Using Jax data structures.
'''
import numpy as np
import jax.numpy as jnp
import jax
from noci_jax import slater
from jax.config import config
config.update("jax_enable_x64", True)
# import os 
# os.environ["XLA_PYTHON_CLIENT_PREALLOCATE"]="false"
# os.environ["XLA_PYTHON_CLIENT_MEM_FRACTION"]=".XX"
# os.environ["XLA_PYTHON_CLIENT_ALLOCATOR"]="platform"


def tvecs_to_rmats(tvecs, nvir, nocc, occ_mat=None):

    vecs_all = tvecs.reshape(-1, nvir, nocc)
    nvecs = vecs_all.shape[0]
    if occ_mat is None:
        occ_mat = jnp.eye(nocc)
    Imats = jnp.tile(occ_mat, (nvecs)).T.reshape(nvecs, nocc, nocc) # 2 for spins
    rmats = jnp.concatenate([Imats, vecs_all], axis=1)
    return rmats


def add_tvec_hf(tmats):
    return slater.add_tvec_hf(tmats)


def gen_rmat_hf(nvir, nocc):
    rot0_u = jnp.zeros((nvir+nocc, nocc))
    rot0_u = rot0_u.at[:nocc, :nocc].set(jnp.eye(nocc))
    rmats_new = jnp.array([rot0_u]) # the HF state

    return rmats_new

def metric_rmats(rmat1, rmat2):
    '''
    Evaluate the overlap between the two Slater determinants represented by rotation matrices.
    '''
    mat = jnp.einsum('ji, jk -> ik', rmat1.conj(), rmat2)
    ovlp = jnp.linalg.det(mat) ** 2
    return ovlp


def orthonormal_mos(tmats):
    return slater.orthonormal_mos(tmats)

def rotate_rmats(rmats, U):
    '''
    Rotate the rmats based on Unitary matrix U.
    args:
        rmats: (nr, s, norb, nocc) array
        U: (s, norb, norb) array
    Returns:
        UR for each R
    '''
    return jnp.einsum('ij, njk -> nik', U, rmats)


def noci_energy(rmats, mo_coeff, h1e, h2e, return_mats=False, lc_coeffs=None, e_nuc=0.0):
    '''
    NOCI energy from the determinants generated by rmats.
    Returns:
        float
    '''
    if return_mats:
        return noci_matrices(rmats, mo_coeff, h1e, h2e)

    if lc_coeffs is not None:
        return noci_energy_lc(rmats, mo_coeff, h1e, h2e, lc_coeffs, e_nuc)

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("ij, njk -> nik", mo_coeff, rmats)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmji -> nm", h1e, trdms) * 2
    J = jnp.einsum("ijkl, nmlk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmji -> nm", J, trdms) * 2
    K = jnp.einsum("ijkl, nmjk -> nmil", h2e, trdms)
    E2K = jnp.einsum("nmij, nmji ->nm", K, trdms)

    E2 = E2J - E2K
    hmat = (E1 + E2) * smat
    energy = solve_lc_coeffs(hmat, smat, return_vec=False)
    return energy + e_nuc

@jax.jit
def noci_energy_jit(rmats, mo_coeff, h1e, h2e, return_mats=False, lc_coeffs=None, e_nuc=0.0):
    '''
    NOCI energy from the determinants generated by rmats.
    Returns:
        float
    '''
    if return_mats:
        return noci_matrices(rmats, mo_coeff, h1e, h2e)

    if lc_coeffs is not None:
        return noci_energy_lc(rmats, mo_coeff, h1e, h2e, lc_coeffs, e_nuc)

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("ij, njk -> nik", mo_coeff, rmats)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmji -> nm", h1e, trdms) * 2
    J = jnp.einsum("ijkl, nmlk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmji -> nm", J, trdms) * 2
    K = jnp.einsum("ijkl, nmjk -> nmil", h2e, trdms)
    E2K = jnp.einsum("nmij, nmji ->nm", K, trdms)

    E2 = E2J - E2K
    hmat = (E1 + E2) * smat
    energy = solve_lc_coeffs(hmat, smat, return_vec=False)
    return energy + e_nuc


@jax.jit
def noci_energy_lc(rmats, mo_coeff, h1e, h2e, lc_coeffs, e_nuc=0.0):

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("ij, njk -> nik", mo_coeff, rmats)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmji -> nm", h1e, trdms) * 2
    J = jnp.einsum("ijkl, nmlk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmji -> nm", J, trdms) * 2
    K = jnp.einsum("ijkl, nmjk -> nmil", h2e, trdms)
    E2K = jnp.einsum("nmij, nmji ->nm", K, trdms)

    E2 = E2J - E2K
    hmat = (E1 + E2) * smat

    h = lc_coeffs.T.conj().dot(hmat).dot(lc_coeffs)
    s = lc_coeffs.T.conj().dot(smat).dot(lc_coeffs)
    energy = (h / s)

    return energy + e_nuc


def noci_matrices(rmats, mo_coeff, h1e, h2e):
    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("ij, njk -> nik", mo_coeff, rmats)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets, inv_metrics, sdets.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmji -> nm", h1e, trdms) * 2
    J = jnp.einsum("ijkl, nmlk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmji -> nm", J, trdms) * 2
    K = jnp.einsum("ijkl, nmjk -> nmil", h2e, trdms)
    E2K = jnp.einsum("nmij, nmji ->nm", K, trdms)

    E2 = E2J - E2K
    hmat = (E1 + E2) * smat
    return hmat, smat


def solve_lc_coeffs(hmat, smat, return_vec=False):
    '''
    Solve the eigenvalue problem Hc = ESc. 
    
    Returns:
        double, ground state energy
        if return_vec:
            1D array, linear combination coefficient
    '''
    energy, c = _generalized_eigh(hmat, smat)

    if return_vec:
        return energy, c
    else:
        return energy
    

def make_rdm1(rmats, mo_coeff, lc_coeff):
    '''
    Make rdm1 of NOCI in the AO basis for UHF.
    Return: array of size (2, N, N)
    '''
    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("ij, njk -> nik", mo_coeff, rmats)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets, inv_metrics, sdets.conj())
    trdms = jnp.einsum("nmij, nm -> nmij", trdms, smat)

    top = jnp.einsum("n, m, nmij -> ij", lc_coeff.conj(), lc_coeff, trdms) 
    bot = jnp.einsum("n, m, nm ->", lc_coeff.conj(), lc_coeff, smat)

    return top/bot


def make_rdm12(rmats, mo_coeff, lc_coeff):
    '''
    Make 2RDM given an NOCI.
    Return: (p,q,r,s) = <a^dag_p a_q a^_r a_s>
    order: uuuu, uudd, dduu, dddd

    '''
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets = jnp.einsum("ij, njk -> nik", mo_coeff, rmats)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets, inv_metrics, sdets.conj())
    dm1s = jnp.einsum("nmij, nm -> nmij", trdms, smat)
    dm1_u = trdms

    dm2s = jnp.einsum("nmij, nmkl -> nmijkl", dm1_u, dm1_u) \
             - jnp.einsum("nmil, nmkj -> nmijkl", dm1_u, dm1_u)
    
    dm2s = jnp.einsum("nmijkl, nm -> nmijkl", dm2s, smat)

    dm1s = jnp.einsum("n, m, nmij -> ij", lc_coeff.conj(), lc_coeff, dm1s) 
    dm2s = jnp.einsum("n, m, nmijkl -> ijkl", lc_coeff.conj(), lc_coeff, dm2s)

    phi_norm = jnp.einsum("n, m, nm ->", lc_coeff.conj(), lc_coeff, smat)

    return dm1s/phi_norm, dm2s/phi_norm


def get_smat(rmats):
    '''
    Get the overlap matrix of the given determinants.
    '''
    metrics = jnp.einsum('nji, mjk -> nmik', rmats.conj(), rmats)
    smat = jnp.linalg.det(metrics) ** 2
    return smat

def expand_hs(hmat0, smat0, rmats_n, rmats_fix, h1e, h2e, mo_coeff):
    '''
    Expand the H matrix and S matrix
    | (fix, fix)   (fix, n)|
    | (n, fix)     (n, n)  |
    (fix, fix) is given by h_n and s_n
    we evaluate (n, fix) and (n, n)  
    '''
    n_fix = len(rmats_fix)
    n_new = len(rmats_n)
    n_tot = n_fix + n_new
    
    hm = jnp.zeros((n_tot, n_tot))
    sm = jnp.zeros((n_tot, n_tot))
    hm = hm.at[:n_fix, :n_fix].set(hmat0)
    sm = sm.at[:n_fix, :n_fix].set(smat0)

    # generate hmat and smat for the lower left block and upper right block
    h_new, s_new = _gen_hsmat(rmats_n, rmats_fix, mo_coeff, h1e, h2e)
    hm = hm.at[n_fix:, :n_fix].set(h_new)
    hm = hm.at[:n_fix, n_fix:].set(h_new.T.conj())
    sm = sm.at[n_fix:, :n_fix].set(s_new)
    sm = sm.at[:n_fix, n_fix:].set(s_new.T.conj())

    # generate hmat and smat for the lower diagonal block
    h_new, s_new = noci_energy(rmats_n, mo_coeff, h1e, h2e, return_mats=True)
    hm = hm.at[n_fix:, n_fix:].set(h_new)
    sm = sm.at[n_fix:, n_fix:].set(s_new)

    return hm, sm


def expand_smat(smat_fix, rmats_fix, rmats_new):
    '''
    Given the previous smat from rmats_fix, add the rows and columns from
    rmats_new.
    '''
    n_fix = len(rmats_fix)
    n_new = len(rmats_new)
    n_tot = n_fix + n_new
    metrics_mix = jnp.einsum('nji, mjk -> nmik', rmats_fix.conj(), rmats_new)
    smat_left = jnp.linalg.det(metrics_mix) ** 2
    metrics_new = jnp.einsum('nji, mjk -> nmik', rmats_new.conj(), rmats_new)
    smat_new = jnp.linalg.det(metrics_new) ** 2

    smat = jnp.zeros((n_tot, n_tot))
    smat = smat.at[:n_fix, :n_fix].set(smat_fix)
    smat = smat.at[:n_fix, n_fix:].set(smat_left)
    smat = smat.at[n_fix:, :n_fix].set(smat_left.conj().T)
    smat = smat.at[n_fix:, n_fix:].set(smat_new)
    return smat
    

def _gen_hsmat(rmats1, rmats2, mo_coeff, h1e, h2e):
    '''
    Return the matrices of the Hamiltonian and overlap matrix with
    respect to two sets of rotation matrices.
    '''

    # first calculate metric and thus overlap
    metrics_all = jnp.einsum('nji, mjk -> nmik', rmats1.conj(), rmats2)
    smat = jnp.linalg.det(metrics_all) ** 2

    # transition density matrices
    inv_metrics = jnp.linalg.inv(metrics_all)
    sdets1 = jnp.einsum("ij, njk -> nik", mo_coeff, rmats1)
    sdets2 = jnp.einsum("ij, njk -> nik", mo_coeff, rmats2)
    trdms = jnp.einsum("mij, nmjk, nlk -> nmil", sdets2, inv_metrics, sdets1.conj())

    # transition hamiltonian
    E1 = jnp.einsum("ij, nmji -> nm", h1e, trdms) * 2
    J = jnp.einsum("ijkl, nmlk -> nmij", h2e, trdms)
    E2J = jnp.einsum("nmij, nmji -> nm", J, trdms) * 2
    K = jnp.einsum("ijkl, nmjk -> nmil", h2e, trdms)
    E2K = jnp.einsum("nmij, nmji ->nm", K, trdms)

    E2 = E2J - E2K
    hmat = (E1 + E2) * smat
   
    return hmat, smat

def _generalized_eigh(A, B):
    L = jnp.linalg.cholesky(B)
    L_inv = jnp.linalg.inv(L)
    A_redo = L_inv @ A @ L_inv.T
    e, v = jnp.linalg.eigh(A_redo)
    e0 = e[0]
    v0 = v[:, 0]
    c0 = L_inv.T @ v0 # rotate back 

    return e0, c0

if __name__ == "__main__":
    print("Main function:\n")
